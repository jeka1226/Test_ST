from __future__ import annotations

import time
from collections import deque
from threading import Semaphore
from threading import Thread
from typing import Dict, TYPE_CHECKING
from src.ServerRequest import ServerResultRequest

if TYPE_CHECKING:
    from Server.ServerEventLoops import UserEventLoop
    from src.ServerRequest import ServerTask


class Worker:
    """
    Class contains thread which calculate tasks.
    Any server thread can add task.
    Semaphore is used to add task.
    """
    def __init__(self):
        self.semaphore = Semaphore(1)  # add task semaphore
        self.current_identifier = 0  # counter of task identifier
        self.tasks: Dict[int: WorkerTask, ...] = dict()  # dictionary of tasks Dict[identifier: WorkerTask]
        self.deque = deque()  # queue of task identifiers
        self.is_active = True  # is thread active
        self.thread = Thread(target=self.run, daemon=False)  # worker Thread

    def start(self):
        """star worker"""
        self.thread.start()  # start Thread

    def add_task(self, task: ServerTask) -> int:
        """
        Create task for Worker
        :param task: task generated by UserEventLoop class
        :return: task identifier
        """
        self.current_identifier += 1  # increase counter

        # create worker task
        worker_task = WorkerTask(
            task.event_handler,
            task.request_identifier_on_client,
            task.command,
            task.error,
            task.task_type,
            task.is_batch_processing_mode,
            task.request_identifier_on_result,
            task.data,
            self.current_identifier)

        self.tasks[self.current_identifier] = worker_task  # add worker task in tasks container
        self.deque.appendleft(self.current_identifier)  # add worker task identifier in queue
        return self.current_identifier

    def run(self):
        """worker event loop"""
        while self.is_active:
            if len(self.deque) > 0:  # run task if there is task to run
                identifier = self.deque.pop()  # pop identifier from queue
                self.tasks[identifier].run()  # get task from dictionary of tasks and run
            else:  # sleep if there is task to run
                time.sleep(0.1)


class WorkerTask:
    def __init__(self,
                 event_handler: UserEventLoop,
                 request_identifier_on_client: int,
                 command: str,
                 error: str,
                 task_type: str,
                 is_batch_processing_mode: bool,
                 request_identifier_on_result: int,
                 data: str,
                 identifier: str):
        """create new worker task"""

        self.event_handler: UserEventLoop = event_handler
        self.request_identifier_on_client: int = request_identifier_on_client
        self.command: str = command
        self.error: str = error
        self.task_type: str = task_type
        self.is_batch_processing_mode = is_batch_processing_mode
        self.request_identifier_on_result = request_identifier_on_result
        self.data = data
        self.identifier = identifier

        self.result = None
        self.status: str = 'in queue'


    def symbol_repeat(self):
        """
        repeat symbols according position
        """
        time.sleep(7)
        self.result = ''.join(list(s*(num+1) for num, s in enumerate(self.data)))


    def pair_permutation(self):
        """
        pairwise characters in a string
        """
        time.sleep(5)
        len_data = len(self.data)
        self.result = ''.join(
            list(
                self.data[num + 1] + self.data[num]
                if num < len_data - 1
                else self.data[num]
                for num in range(0, len_data, 2)
            )
        )


    def reverse(self):
        """
         reverse symbols in value
        """
        time.sleep(2)
        self.result = self.data[::-1]


    def run(self):
        """
        start worker task
        """
        self.status = 'in work'  # update status
        self.__getattribute__(self.task_type.lstrip('-'))()  # run method corresponding to the task_type
        self.status = 'done'  # update status

        if self.is_batch_processing_mode:  # if request was in batch processing mode, create response
            # create result response
            result_response = ServerResultRequest(
                self.event_handler,
                self.request_identifier_on_result,
                'result',
                None,
                self.identifier,
                self.result)

            self.event_handler.data_to_send.appendleft(result_response)  # add response in data_to_send queue


worker = Worker()  # create worker, which do requested tasks
